(in-package :cl-hashing)

(defmacro siprounds (rounds v0 v1 v2 v3)
  `(loop for i of-type uint8 from 0 below ,rounds
         do (setf ,v0 (m64 (+ ,v0 ,v1))
                  ,v1 (rotl64 13 ,v1)
                  ,v1 (m64 (logxor ,v1 ,v0))
                  ,v0 (rotl64 32 ,v0)
                  ,v2 (m64 (+ ,v2 ,v3))
                  ,v3 (rotl64 16 ,v3)
                  ,v3 (m64 (logxor ,v3 ,v2))
                  ,v0 (m64 (+ ,v0 ,v3))
                  ,v3 (rotl64 21 ,v3)
                  ,v3 (m64 (logxor ,v3 ,v0))
                  ,v2 (m64 (+ ,v2 ,v1))
                  ,v1 (rotl64 17 ,v1)
                  ,v1 (m64 (logxor ,v1 ,v2))
                  ,v2 (rotl64 32 ,v2))))

(defmacro mid-mix-1-128 (v) `(setf ,v (logxor #xee ,v)))
(defmacro mid-mix-2-128 (v) `(setf ,v (logxor #xee ,v)))
(defmacro finalize-128 (b d-rounds v0 v1 v2 v3)
  `(let ((ret (ash ,b 64)))
     (declare (uint128 ret))
     (setf ,v1 (logxor ,v1 #xdd))
     (siprounds ,d-rounds ,v0 ,v1 ,v2 ,v3)
     (setf ,b (logxor ,v0 ,v1 ,v2 ,v3))
     (logior ret ,b)))
  
(defmacro mid-mix-1-64 (v))
(defmacro mid-mix-2-64 (v) `(setf ,v (logxor ,v #xff)))
(defmacro finalize-64 (b d-rounds v0 v1 v2 v3) `(values ,b))
(defmacro finalize-fixnum (b d-rounds v0 v1 v2 v3) `(values (mfix ,b)))

(defmacro define-siphash (name (out-type key c-rounds d-rounds mid-mix-1 mid-mix-2 finalizer))
  (with-unique-names (k0 k1)
    `(let ((,k0 (ldb (byte 64 64) ,key))
           (,k1 (ldb (byte 64 0) ,key)))
       (declaim (ftype (function (octet-array uint32) ,out-type) ,name))
       (defun ,name (buffer size)
         (declare (optimize (speed 3) (safety 0) (debug 0)))
         (let ((v0 #x736f6d6570736575)
               (v1 #0x646f72616e646f6d)
               (v2 #x6c7967656e657261)
               (v3 #x7465646279746573)
               (b (m64 (ash size 56)))
               (last-index (- size (mod size 8)))
               (left (logand size 7)))
           (declare (uint64 v0 v1 v2 v3 ,k0 ,k1 b))
           (setf v3 (logxor v3 ,k1)
                 v2 (logxor v2 ,k0)
                 v1 (logxor v1 ,k1)
                 v0 (logxor v0 ,k0))

           (,mid-mix-1 v1)
           
           (loop for index of-type uint32 from 0 below last-index by 8
                 do (let ((m (bytes->le64 buffer index)))
                      (declare (uint64 m))
                      (setf v3 (logxor m v3))
                      (siprounds ,c-rounds v0 v1 v2 v3)
                      (setf v0 (logxor v0 m))))
           
           (loop for index from 0 below left
                 do (setf b (logior b (ash (aref buffer (+ last-index index)) (* 8 index)))))
           
           (setf v3 (logxor v3 b))
           (siprounds ,c-rounds v0 v1 v2 v3)
           (setf v0 (logxor v0 b))
           (,mid-mix-2 v2)
           (siprounds ,d-rounds v0 v1 v2 v3)
           (setf b (logxor v0 v1 v2 v3))
           (,finalizer b ,d-rounds v0 v1 v2 v3))))))

(defmacro define-siphash/64 (name (key c-rounds d-rounds))
  `(define-siphash ,name (uint64 ,key ,c-rounds ,d-rounds mid-mix-1-64 mid-mix-2-64 finalize-64)))

(defmacro define-siphash/128 (name (key c-rounds d-rounds))
  `(define-siphash ,name (uint128 ,key ,c-rounds ,d-rounds mid-mix-1-128 mid-mix-2-128 finalize-128)))

(defmacro define-siphash/fixnum (name (key c-rounds d-rounds))
  `(define-siphash ,name (fixnum ,key ,c-rounds ,d-rounds mid-mix-1-64 mid-mix-2-64 finalize-fixnum)))
